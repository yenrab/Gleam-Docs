{
  "@context": {
    "@vocab": "https://aalang.org/spec",
    "ex": "https://aalang.org/example/"
  },
  "@graph": [
    {
      "@id": "ex:gleam_dynamic_decode_module",
      "@type": "Module",
      "name": "gleam.dynamic.decode",
      "description": "The `Dynamic` type is used to represent dynamically typed data. That is, data\n//// that we don't know the precise type of yet, so we need to introspect the data to\n//// see if it is of the desired type before we can use it. Typically data like this\n//// would come from user input or from untyped languages such as Erlang or JavaScript.\n////\n//// This module provides the `Decoder` type and associated functions, which provides\n//// a type-safe and composable way to convert dynamic data into some desired type,\n//// or into errors if the data doesn't have the desired structure.\n////\n//// The `Decoder` type is generic and has 1 type parameter, which is the type that\n//// it attempts to decode. A `Decoder(String)` can be used to decode strings, and a\n//// `Decoder(Option(Int))` can be used to decode `Option(Int)`s\n////\n//// Decoders work using _runtime reflection_ and the data structures of the target\n//// platform. Differences between Erlang and JavaScript data structures may impact\n//// your decoders, so it is important to test your decoders on all supported\n//// platforms.\n////\n//// The decoding technique used by this module was inspired by Juraj Petr\u00e1\u0161'\n//// [Toy](https://github.com/Hackder/toy), Go's `encoding/json`, and Elm's\n//// `Json.Decode`. Thank you to them!\n////\n//// # Examples\n////\n//// Dynamic data may come from various sources and so many different syntaxes could\n//// be used to describe or construct them. In these examples a pseudocode\n//// syntax is used to describe the data.\n////\n//// ## Simple types\n////\n//// This module defines decoders for simple data types such as [`string`](#string),\n//// [`int`](#int), [`float`](#float), [`bit_array`](#bit_array), and [`bool`](#bool).\n////\n//// ```gleam\n//// // Data:\n//// // \"Hello, Joe!\"\n////\n//// let result = decode.run(data, decode.string)\n//// assert result == Ok(\"Hello, Joe!\")\n//// ```\n////\n//// ## Lists\n////\n//// The [`list`](#list) decoder decodes `List`s. To use it you must construct it by\n//// passing in another decoder into the `list` function, which is the decoder that\n//// is to be used for the elements of the list, type checking both the list and its\n//// elements.\n////\n//// ```gleam\n//// // Data:\n//// // [1, 2, 3, 4]\n////\n//// let result = decode.run(data, decode.list(decode.int))\n//// assert result == Ok([1, 2, 3, 4])\n//// ```\n////\n//// On Erlang this decoder can decode from lists, and on JavaScript it can\n//// decode from lists as well as JavaScript arrays.\n////\n//// ## Options\n////\n//// The [`optional`](#optional) decoder is used to decode values that may or may not\n//// be present. In other environment these might be called \"nullable\" values.\n////\n//// Like the `list` decoder, the `optional` decoder takes another decoder,\n//// which is used to decode the value if it is present.\n////\n//// ```gleam\n//// // Data:\n//// // 12.45\n////\n//// let result = decode.run(data, decode.optional(decode.float))\n//// assert result == Ok(option.Some(12.45))\n//// ```\n//// ```gleam\n//// // Data:\n//// // null\n////\n//// let result = decode.run(data, decode.optional(decode.int))\n//// assert result == Ok(option.None)\n//// ```\n////\n//// This decoder knows how to handle multiple different runtime representations of\n//// absent values, including `Nil`, `None`, `null`, and `undefined`.\n////\n//// ## Dicts\n////\n//// The [`dict`](#dict) decoder decodes `Dicts` and contains two other decoders, one\n//// for the keys, one for the values.\n////\n//// ```gleam\n//// // Data:\n//// // { \"Lucy\" -> 10, \"Nubi\" -> 20 }\n////\n//// let result = decode.run(data, decode.dict(decode.string, decode.int))\n//// assert result == Ok(dict.from_list([\n////   #(\"Lucy\", 10),\n////   #(\"Nubi\", 20),\n//// ]))\n//// ```\n////\n//// ## Indexing objects\n////\n//// The [`at`](#at) decoder can be used to decode a value that is nested within\n//// key-value containers such as Gleam dicts, Erlang maps, or JavaScript objects.\n////\n//// ```gleam\n//// // Data:\n//// // { \"one\" -> { \"two\" -> 123 } }\n////\n//// let result = decode.run(data, decode.at([\"one\", \"two\"], decode.int))\n//// assert result == Ok(123)\n//// ```\n////\n//// ## Indexing arrays\n////\n//// If you use ints as keys then the [`at`](#at) decoder can be used to index into\n//// array-like containers such as Gleam or Erlang tuples, or JavaScript arrays.\n////\n//// ```gleam\n//// // Data:\n//// // [\"one\", \"two\", \"three\"]\n////\n//// let result = decode.run(data, decode.at([1], decode.string))\n//// assert result == Ok(\"two\")\n//// ```\n////\n//// ## Records\n////\n//// Decoding records from dynamic data is more complex and requires combining a\n//// decoder for each field and a special constructor that builds your records with\n//// the decoded field values.\n////\n//// ```gleam\n//// // Data:\n//// // {\n//// //   \"score\" -> 180,\n//// //   \"name\" -> \"Mel Smith\",\n//// //   \"is-admin\" -> false,\n//// //   \"enrolled\" -> true,\n//// //   \"colour\" -> \"Red\",\n//// // }\n////\n//// let decoder = {\n////   use name <- decode.field(\"name\", decode.string)\n////   use score <- decode.field(\"score\", decode.int)\n////   use colour <- decode.field(\"colour\", decode.string)\n////   use enrolled <- decode.field(\"enrolled\", decode.bool)\n////   decode.success(Player(name:, score:, colour:, enrolled:))\n//// }\n////\n//// let result = decode.run(data, decoder)\n//// assert result == Ok(Player(\"Mel Smith\", 180, \"Red\", True))\n//// ```\n////\n//// ## Enum variants\n////\n//// Imagine you have a custom type where all the variants do not contain any values.\n////\n//// ```gleam\n//// pub type PocketMonsterType {\n////   Fire\n////   Water\n////   Grass\n////   Electric\n//// }\n//// ```\n////\n//// You might choose to encode these variants as strings, `\"fire\"` for `Fire`,\n//// `\"water\"` for `Water`, and so on. To decode them you'll need to decode the dynamic\n//// data as a string, but then you'll need to decode it further still as not all\n//// strings are valid values for the enum. This can be done with the `then`\n//// function, which enables running a second decoder after the first one\n//// succeeds.\n////\n//// ```gleam\n//// let decoder = {\n////   use decoded_string <- decode.then(decode.string)\n////   case decoded_string {\n////     // Return succeeding decoders for valid strings\n////     \"fire\" -> decode.success(Fire)\n////     \"water\" -> decode.success(Water)\n////     \"grass\" -> decode.success(Grass)\n////     \"electric\" -> decode.success(Electric)\n////     // Return a failing decoder for any other strings\n////     _ -> decode.failure(Fire, \"PocketMonsterType\")\n////   }\n//// }\n////\n//// let result = decode.run(dynamic.string(\"water\"), decoder)\n//// assert result == Ok(Water)\n////\n//// let result = decode.run(dynamic.string(\"wobble\"), decoder)\n//// assert result == Error([DecodeError(\"PocketMonsterType\", \"String\", [])])\n//// ```\n////\n//// ## Record variants\n////\n//// Decoding type variants that contain other values is done by combining the\n//// techniques from the \"enum variants\" and \"records\" examples. Imagine you have\n//// this custom type that you want to decode:\n////\n//// ```gleam\n//// pub type PocketMonsterPerson {\n////   Trainer(name: String, badge_count: Int)\n////   GymLeader(name: String, speciality: PocketMonsterType)\n//// }\n//// ```\n//// And you would like to be able to decode these from dynamic data like this:\n//// ```erlang\n//// {\n////   \"type\" -> \"trainer\",\n////   \"name\" -> \"Ash\",\n////   \"badge-count\" -> 1,\n//// }\n//// ```\n//// ```erlang\n//// {\n////   \"type\" -> \"gym-leader\",\n////   \"name\" -> \"Misty\",\n////   \"speciality\" -> \"water\",\n//// }\n//// ```\n////\n//// Notice how both documents have a `\"type\"` field, which is used to indicate which\n//// variant the data is for.\n////\n//// First, define decoders for each of the variants:\n////\n//// ```gleam\n//// let trainer_decoder = {\n////   use name <- decode.field(\"name\", decode.string)\n////   use badge_count <- decode.field(\"badge-count\", decode.int)\n////   decode.success(Trainer(name, badge_count))\n//// }\n////\n//// let gym_leader_decoder = {\n////   use name <- decode.field(\"name\", decode.string)\n////   use speciality <- decode.field(\"speciality\", pocket_monster_type_decoder)\n////   decode.success(GymLeader(name, speciality))\n//// }\n//// ```\n////\n//// A third decoder can be used to extract and decode the `\"type\"` field, and the\n//// expression can evaluate to whichever decoder is suitable for the document.\n////\n//// ```gleam\n//// // Data:\n//// // {\n//// //   \"type\" -> \"gym-leader\",\n//// //   \"name\" -> \"Misty\",\n//// //   \"speciality\" -> \"water\",\n//// // }\n////\n//// let decoder = {\n////   use tag <- decode.field(\"type\", decode.string)\n////   case tag {\n////     \"gym-leader\" -> gym_leader_decoder\n////     _ -> trainer_decoder\n////   }\n//// }\n////\n//// let result = decode.run(data, decoder)\n//// assert result == Ok(GymLeader(\"Misty\", Water))\n//// ```",
      "functions": [
        {
          "@id": "ex:gleam_dynamic_decode_subfield"
        },
        {
          "@id": "ex:gleam_dynamic_decode_run"
        },
        {
          "@id": "ex:gleam_dynamic_decode_at"
        },
        {
          "@id": "ex:gleam_dynamic_decode_success"
        },
        {
          "@id": "ex:gleam_dynamic_decode_decode_error"
        },
        {
          "@id": "ex:gleam_dynamic_decode_field"
        },
        {
          "@id": "ex:gleam_dynamic_decode_optional_field"
        },
        {
          "@id": "ex:gleam_dynamic_decode_optionally_at"
        },
        {
          "@id": "ex:gleam_dynamic_decode_list"
        },
        {
          "@id": "ex:gleam_dynamic_decode_dict"
        },
        {
          "@id": "ex:gleam_dynamic_decode_optional"
        },
        {
          "@id": "ex:gleam_dynamic_decode_map"
        },
        {
          "@id": "ex:gleam_dynamic_decode_map_errors"
        },
        {
          "@id": "ex:gleam_dynamic_decode_collapse_errors"
        },
        {
          "@id": "ex:gleam_dynamic_decode_then"
        },
        {
          "@id": "ex:gleam_dynamic_decode_one_of"
        },
        {
          "@id": "ex:gleam_dynamic_decode_failure"
        },
        {
          "@id": "ex:gleam_dynamic_decode_new_primitive_decoder"
        },
        {
          "@id": "ex:gleam_dynamic_decode_recursive"
        }
      ]
    },
    {
      "@id": "ex:gleam_dynamic_decode_subfield",
      "@type": "Function",
      "name": "subfield",
      "module": "gleam.dynamic.decode",
      "purpose": "The same as [`field`](#field), except taking a path to the value rather",
      "parameters": [
        {
          "name": "field_path",
          "label": null,
          "type": "List(name)"
        },
        {
          "name": "field_decoder",
          "label": null,
          "type": "Decoder(t)"
        },
        {
          "name": "next",
          "label": null,
          "type": "fn(t) -> Decoder(final)"
        }
      ],
      "returnType": "Decoder(final)",
      "whyHelpful": "than a field name.",
      "examples": []
    },
    {
      "@id": "ex:gleam_dynamic_decode_run",
      "@type": "Function",
      "name": "run",
      "module": "gleam.dynamic.decode",
      "purpose": "Run a decoder on a `Dynamic` value, decoding the value if it is of the",
      "parameters": [
        {
          "name": "data",
          "label": null,
          "type": "Dynamic"
        },
        {
          "name": "decoder",
          "label": null,
          "type": "Decoder(t)"
        }
      ],
      "returnType": "Result(t, List(DecodeError))",
      "whyHelpful": "desired type, or returning errors.",
      "examples": []
    },
    {
      "@id": "ex:gleam_dynamic_decode_at",
      "@type": "Function",
      "name": "at",
      "module": "gleam.dynamic.decode",
      "purpose": "A decoder that decodes a value that is nested within other values. For",
      "parameters": [
        {
          "name": "path",
          "label": null,
          "type": "List(segment)"
        },
        {
          "name": "inner",
          "label": null,
          "type": "Decoder(a)"
        }
      ],
      "returnType": "Decoder(a)",
      "whyHelpful": "example, decoding a value that is within some deeply nested JSON objects.",
      "examples": [
        "decode.run(data, decoder)",
        "decode.run(decode.optional(decode.int))"
      ]
    },
    {
      "@id": "ex:gleam_dynamic_decode_success",
      "@type": "Function",
      "name": "success",
      "module": "gleam.dynamic.decode",
      "purpose": "Finalise a decoder having successfully extracted a value.",
      "parameters": [
        {
          "name": "data",
          "label": null,
          "type": "t"
        }
      ],
      "returnType": "Decoder(t)",
      "whyHelpful": "let data = dynamic.properties([",
      "examples": []
    },
    {
      "@id": "ex:gleam_dynamic_decode_decode_error",
      "@type": "Function",
      "name": "decode_error",
      "module": "gleam.dynamic.decode",
      "purpose": "Construct a decode error for some unexpected dynamic data.",
      "parameters": [
        {
          "name": "expected",
          "label": "expected",
          "type": "String"
        },
        {
          "name": "found",
          "label": "found",
          "type": "Dynamic"
        }
      ],
      "returnType": "List(DecodeError)",
      "whyHelpful": "",
      "examples": []
    },
    {
      "@id": "ex:gleam_dynamic_decode_field",
      "@type": "Function",
      "name": "field",
      "module": "gleam.dynamic.decode",
      "purpose": "Run a decoder on a field of a `Dynamic` value, decoding the value if it is",
      "parameters": [
        {
          "name": "field_name",
          "label": null,
          "type": "name"
        },
        {
          "name": "field_decoder",
          "label": null,
          "type": "Decoder(t)"
        },
        {
          "name": "next",
          "label": null,
          "type": "fn(t) -> Decoder(final)"
        }
      ],
      "returnType": "Decoder(final)",
      "whyHelpful": "This function will index into dictionaries with any key type, and if the key is an int then it'll also index into Erlang tuples and JavaScript arrays, and the first eight elements of Gleam lists. # Examples If you wish to decode a value that is more deeply nested within the dynamic data, see [`subfield`](#subfield) and [`at`](#at).",
      "examples": []
    },
    {
      "@id": "ex:gleam_dynamic_decode_optional_field",
      "@type": "Function",
      "name": "optional_field",
      "module": "gleam.dynamic.decode",
      "purpose": "Run a decoder on a field of a `Dynamic` value, decoding the value if it is",
      "parameters": [
        {
          "name": "key",
          "label": null,
          "type": "name"
        },
        {
          "name": "default",
          "label": null,
          "type": "t"
        },
        {
          "name": "field_decoder",
          "label": null,
          "type": "Decoder(t)"
        },
        {
          "name": "next",
          "label": null,
          "type": "fn(t) -> Decoder(final)"
        }
      ],
      "returnType": "Decoder(final)",
      "whyHelpful": "of the desired type, or returning errors. The given default value is",
      "examples": []
    },
    {
      "@id": "ex:gleam_dynamic_decode_optionally_at",
      "@type": "Function",
      "name": "optionally_at",
      "module": "gleam.dynamic.decode",
      "purpose": "A decoder that decodes a value that is nested within other values. For",
      "parameters": [
        {
          "name": "path",
          "label": null,
          "type": "List(segment)"
        },
        {
          "name": "default",
          "label": null,
          "type": "a"
        },
        {
          "name": "inner",
          "label": null,
          "type": "Decoder(a)"
        }
      ],
      "returnType": "Decoder(a)",
      "whyHelpful": "example, decoding a value that is within some deeply nested JSON objects.",
      "examples": [
        "decode.run(data, decoder)"
      ]
    },
    {
      "@id": "ex:gleam_dynamic_decode_list",
      "@type": "Function",
      "name": "list",
      "module": "gleam.dynamic.decode",
      "purpose": "A decoder that decodes lists where all elements are decoded with a given",
      "parameters": [
        {
          "name": "inner",
          "label": "of",
          "type": "Decoder(a)"
        }
      ],
      "returnType": "Decoder(List(a))",
      "whyHelpful": "let result =",
      "examples": []
    },
    {
      "@id": "ex:gleam_dynamic_decode_dict",
      "@type": "Function",
      "name": "dict",
      "module": "gleam.dynamic.decode",
      "purpose": "A decoder that decodes dicts where all keys and vales are decoded with",
      "parameters": [
        {
          "name": "key",
          "label": null,
          "type": "Decoder(key)"
        },
        {
          "name": "value",
          "label": null,
          "type": "Decoder(value)"
        }
      ],
      "returnType": "Decoder(Dict(key, value))",
      "whyHelpful": "given decoders.",
      "examples": []
    },
    {
      "@id": "ex:gleam_dynamic_decode_optional",
      "@type": "Function",
      "name": "optional",
      "module": "gleam.dynamic.decode",
      "purpose": "A decoder that decodes nullable values of a type decoded by with a given",
      "parameters": [
        {
          "name": "inner",
          "label": null,
          "type": "Decoder(a)"
        }
      ],
      "returnType": "Decoder(Option(a))",
      "whyHelpful": "This function can handle common representations of null on all runtimes, such as",
      "examples": []
    },
    {
      "@id": "ex:gleam_dynamic_decode_map",
      "@type": "Function",
      "name": "map",
      "module": "gleam.dynamic.decode",
      "purpose": "Apply a transformation function to any value decoded by the decoder.",
      "parameters": [
        {
          "name": "decoder",
          "label": null,
          "type": "Decoder(a)"
        },
        {
          "name": "transformer",
          "label": null,
          "type": "fn(a) -> b"
        }
      ],
      "returnType": "Decoder(b)",
      "whyHelpful": "let decoder = decode.int |> decode.map(int.to_string)",
      "examples": []
    },
    {
      "@id": "ex:gleam_dynamic_decode_map_errors",
      "@type": "Function",
      "name": "map_errors",
      "module": "gleam.dynamic.decode",
      "purpose": "Apply a transformation function to any errors returned by the decoder.",
      "parameters": [
        {
          "name": "decoder",
          "label": null,
          "type": "Decoder(a)"
        },
        {
          "name": "transformer",
          "label": null,
          "type": "fn(List(DecodeError)) -> List(DecodeError)"
        }
      ],
      "returnType": "Decoder(a)",
      "whyHelpful": "",
      "examples": []
    },
    {
      "@id": "ex:gleam_dynamic_decode_collapse_errors",
      "@type": "Function",
      "name": "collapse_errors",
      "module": "gleam.dynamic.decode",
      "purpose": "Replace all errors produced by a decoder with one single error for a named",
      "parameters": [
        {
          "name": "decoder",
          "label": null,
          "type": "Decoder(a)"
        },
        {
          "name": "name",
          "label": null,
          "type": "String"
        }
      ],
      "returnType": "Decoder(a)",
      "whyHelpful": "expected type.",
      "examples": []
    },
    {
      "@id": "ex:gleam_dynamic_decode_then",
      "@type": "Function",
      "name": "then",
      "module": "gleam.dynamic.decode",
      "purpose": "Create a new decoder based upon the value of a previous decoder.",
      "parameters": [
        {
          "name": "decoder",
          "label": null,
          "type": "Decoder(a)"
        },
        {
          "name": "next",
          "label": null,
          "type": "fn(a) -> Decoder(b)"
        }
      ],
      "returnType": "Decoder(b)",
      "whyHelpful": "This may be useful to run one previous decoder to use in further decoding.",
      "examples": []
    },
    {
      "@id": "ex:gleam_dynamic_decode_one_of",
      "@type": "Function",
      "name": "one_of",
      "module": "gleam.dynamic.decode",
      "purpose": "Create a new decoder from several other decoders. Each of the inner",
      "parameters": [
        {
          "name": "first",
          "label": null,
          "type": "Decoder(a)"
        },
        {
          "name": "alternatives",
          "label": "or",
          "type": "List(Decoder(a))"
        }
      ],
      "returnType": "Decoder(a)",
      "whyHelpful": "decoders is run in turn, and the value from the first to succeed is used.",
      "examples": [
        "decode.run(dynamic.int(1000), decoder)"
      ]
    },
    {
      "@id": "ex:gleam_dynamic_decode_failure",
      "@type": "Function",
      "name": "failure",
      "module": "gleam.dynamic.decode",
      "purpose": "Define a decoder that always fails. The parameter for this function is the",
      "parameters": [
        {
          "name": "zero",
          "label": null,
          "type": "a"
        },
        {
          "name": "expected",
          "label": null,
          "type": "String"
        }
      ],
      "returnType": "Decoder(a)",
      "whyHelpful": "this function is the name of the type that has failed to decode. When this decoder is used as part of a larger decoder, the zero value is used as a placeholder so that the rest of the decoder can continue to run and collect all decoding errors.",
      "examples": []
    },
    {
      "@id": "ex:gleam_dynamic_decode_new_primitive_decoder",
      "@type": "Function",
      "name": "new_primitive_decoder",
      "module": "gleam.dynamic.decode",
      "purpose": "Create a decoder for a new data type from a decoding function.",
      "parameters": [
        {
          "name": "name",
          "label": null,
          "type": "String"
        },
        {
          "name": "decoding_function",
          "label": null,
          "type": "fn(Dynamic) -> Result(t, t)"
        }
      ],
      "returnType": "Decoder(t)",
      "whyHelpful": "This function is used for new primitive types. For example, you might define a decoder for Erlang's pid type.",
      "examples": []
    },
    {
      "@id": "ex:gleam_dynamic_decode_recursive",
      "@type": "Function",
      "name": "recursive",
      "module": "gleam.dynamic.decode",
      "purpose": "Create a decoder that can refer to itself, useful for decoding deeply",
      "parameters": [
        {
          "name": "inner",
          "label": null,
          "type": "fn() -> Decoder(a)"
        }
      ],
      "returnType": "Decoder(a)",
      "whyHelpful": "this function could result in an infinite loop. If you are using `field` or other `use`able functions then you may not need to use this function.",
      "examples": []
    }
  ]
}